---
layout: default
title: 性能调整
parent: k-NN
nav_order: 45
---

# 性能调整

此主题提供了性能调整建议，以提高大约k的索引和搜索性能-nn（ann）。从高水平开始-NN根据这些原则工作：
*本地库索引是根据KNN_Vector字段 /（Lucene）段对创建的。
*查询在碎片内依次在段上执行（与任何其他OpenSearch查询相同）。
*该段中的每个本地库索引返回<= k邻居。
*协调员节点从每个碎片返回的邻居那里拾取邻居的最终尺寸数量。

该主题还提供了比较近似k的建议-nn至确切的k-带有得分脚本的nn。

## 索引性能调整

采取以下步骤来提高索引性能，尤其是当您计划一次索引大量向量时：

***禁用刷新间隔**

   禁用刷新间隔（默认= 1秒），或为刷新间隔设置较长的持续时间以避免创建多个小段：

   ```json
   PUT /<index_name>/_settings
   {
       "index" : {
           "refresh_interval" : "-1"
       }
   }
   ```
   **笔记**：确保重新启用`refresh_interval` 索引完成后。

***禁用复制品（无opensearch副本碎片）**

   将副本设置为`0` 为了防止在主要和复制碎片中重复构造本地图书馆索引。当您在索引完成后启用副本时，串行的本机库索引将直接复制。如果您没有复制品，则丢失节点可能会导致数据丢失，因此重要的是数据居住在其他地方很重要，因此在出现问题的情况下，可以重述此初始负载。

***增加索引线的数量**

   如果您选择的硬件具有多个内核，则可以通过加快索引过程来允许本机库索引构建中的多个线程。确定对分配的线程数[knn.algo_param.index_thread_qty]({{site.url}}{{site.baseurl}}/search-plugins/knn/settings#cluster-settings) 环境。

  密切关注CPU利用率，然后选择正确数量的线程。由于本机库索引构建成本高昂，因此拥有多个线程可能会导致额外的CPU负载。

## 搜索性能调整

采取以下步骤来提高搜索性能：

***减少细分计数**

   为了提高搜索性能，您必须控制片段的数量。Lucene的IndexSearcher在碎片中搜索所有细分市场，以找到“大小”最佳结果。

   理想情况下，每个碎片的一个细分市场可提供有关搜索延迟的最佳性能。您可以配置一个索引以具有多个碎片，以避免巨型碎片并实现更多的并行性。

   您可以通过选择较大的刷新间隔来控制片段的数量，或者通过要求OpenSearch通过禁用刷新间隔来减慢细分的创建来控制段。

***热身指数**

   本地库索引是在索引期间构建的，但是在第一次搜索过程中将它们加载到内存中。在Lucene中，依次搜索每个片段（因此，对于K-nn，每个段返回查询点最近的k最近的邻居），基于分数的最高“大小”数量的结果是从分片级别返回的所有结果中返回的（更高的分数=更好的结果）。

   一旦加载了本机库索引（本机库索引在OpenSearch JVM之外加载），OpenSearch将其放在存储器中。初始查询很昂贵，需要几秒钟，而随后的查询速度更快并进行毫秒（假设K-nn断路器未击中）。

   为了避免在第一次查询期间这种延迟罚款，您可以在要搜索的索引上使用热身API操作：

   ```json
   GET /_plugins/_knn/warmup/index1,index2,index3?pretty
   {
     "_shards" : {
       "total" : 6,
       "successful" : 6,
       "failed" : 0
     }
   }
   ```

   热身API操作为指定索引的所有碎片（主要和复制）加载所有本机库索引到缓存中，因此在初始搜索过程中没有加载本机库索引的罚款。

   **笔记**：此API操作仅加载索引的段***看到***进入缓存。如果合并或刷新操作在API运行后完成，或者添加新文档，则需要重新运行API以将这些本机库索引加载到内存中。

***避免阅读存储的字段**

   如果您的用例仅仅是为了读取最近邻居的ID和分数，则可以禁用读取存储的字段，从而节省了从存储字段中检索矢量的时间。

***使用`mmap` 文件I/O**

   对于露西恩-基于近似k-nn搜索，没有加快读取/写入操作的专用缓存层。相反，插件依赖OpenSearch Core中现有的缓存机制。在版本2.4和Lucene的早期-基于近似k-NN搜索，读/写操作默认情况下基于Java Nio，这可能会很慢，具体取决于Lucene版本和每个碎片的段数。从2.5版开始，K-nn启用[`mmap`](https://en.wikipedia.org/wiki/Mmap) 默认情况下，文件I/O时，商店类型为`hybridfs` （opensearch中的默认存储类型）。这会导致快速文件I/O操作，并提高数据摄入和搜索的整体性能。使用使用的两个文件扩展名`mmap` 是`.vec` 和`.vem`。有关这些文件扩展程序的更多信息，请参阅[Lucene文档](https://lucene.apache.org/core/9_0_0/core/org/apache/lucene/codecs/lucene90/Lucene90HnswVectorsFormat.html)。

   这`mmap` 文件I/O使用系统文件缓存，而不是为Java堆分配的内存，因此不需要其他分配。要更改插件设置的扩展名的默认列表，请更新`index.store.hybrid.mmap.extensions` 使用群集级别设置[集群设置API]({{site.url}}{{site.baseurl}}/api-reference/cluster-api/cluster-settings)。**笔记**：这是专家-在更新设置并在更新后重新打开之前，需要关闭索引的级别设置。

## 改善召回

召回取决于多种因素，例如矢量数量，维度数量，段等。搜索大量的小细分市场并汇总结果，比搜索少量的大段和汇总结果更好。本机库索引越大，如果您使用较小的算法参数，失去召回的机会就越大。选择算法参数的较大值应有助于解决此问题，但牺牲搜索延迟和索引时间。话虽这么说，重要的是要了解系统对延迟和准确性的要求，然后选择您希望根据实验所需的索引的段数。

默认参数可在更广泛的用例中工作，但请确保在数据集上运行自己的实验并选择适当的值。用于索引-等级设置，请参阅[索引设置]({{site.url}}{{site.baseurl}}/search-plugins/knn/knn-index#index-settings)。

## 大约最近的邻居与得分脚本

标准k-nn查询和自定义评分选项的性能不同。使用一组代表性的文档进行测试，以查看搜索结果和潜伏期是否与您的期望相匹配。

如果初始过滤器将文档数量减少到不超过20,000，则定制评分效果最好。增加的碎片计数可以提高延迟，但请确保将碎片尺寸保持在[推荐准则]({{site.url}}{{site.baseurl}}/opensearch#primary-and-replica-shards)。

